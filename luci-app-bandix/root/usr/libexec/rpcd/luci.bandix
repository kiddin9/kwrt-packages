#!/bin/sh
# Copyright 2025 timsaya

. /usr/share/libubox/jshn.sh

# 从UCI配置读取端口号，如果读取失败则使用默认端口8686
BANDIX_PORT=$(uci get bandix.general.port 2>/dev/null || echo "8686")
readonly BANDIX_API_BASE="http://127.0.0.1:$BANDIX_PORT"
readonly BANDIX_DEVICES_API="$BANDIX_API_BASE/api/traffic/devices"
readonly BANDIX_LIMITS_API="$BANDIX_API_BASE/api/traffic/limits"
readonly BANDIX_METRICS_API="$BANDIX_API_BASE/api/traffic/metrics"
readonly BANDIX_CONNECTION_API="$BANDIX_API_BASE/api/connection/devices"
readonly BANDIX_DNS_QUERIES_API="$BANDIX_API_BASE/api/dns/queries"
readonly BANDIX_DNS_STATS_API="$BANDIX_API_BASE/api/dns/stats"
readonly BANDIX_SCHEDULE_LIMITS_API="$BANDIX_API_BASE/api/traffic/limits/schedule"

# 通用函数：创建简单的JSON响应
make_value() {
	json_init
	json_add_string "$1" "$2"
	json_dump
	json_cleanup
}

# 通用函数：创建错误响应
make_error() {
	json_init
	json_add_boolean "success" 0
	json_add_string "error" "$1"
	json_dump
	json_cleanup
}

# 通用函数：创建成功响应
make_success() {
	json_init
	json_add_boolean "success" 1
	[ -n "$1" ] && json_add_string "message" "$1"
	json_dump
	json_cleanup
}

# 转义JSON字符串
escape_json_string() {
	echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g'
}

# 获取设备状态
get_device_status() {
	local api_result=$(curl -s --connect-timeout 2 --max-time 5 "$BANDIX_DEVICES_API" 2>/dev/null)
	
	# 检查API调用是否成功
	if [ $? -ne 0 ] || [ -z "$api_result" ]; then
		echo '{"devices":[]}'
		return
	fi
	
	# 提取 data 部分并返回
	local data_part=$(echo "$api_result" | jsonfilter -e '$.data' 2>/dev/null)
	if [ -n "$data_part" ]; then
		echo "$data_part"
	else
		echo '{"devices":[]}'
	fi
}

# 获取历史指标（可选MAC）
get_metrics() {
    local mac="$1"
    local url="$BANDIX_METRICS_API"
    if [ -n "$mac" ]; then
        # 转义MAC
        local mac_escaped=$(echo "$mac" | sed 's/\//\\\//g')
        url="$url?mac=$mac_escaped"
    fi

    # logger "luci.bandix.metrics: entering mac=$mac url=$url"
    local api_result=$(curl -s --connect-timeout 1 --max-time 3 "$url" 2>/dev/null)
    local curl_exit_code=$?
    # logger "luci.bandix.metrics: curl finished with exit code: $curl_exit_code"
    
    if [ $curl_exit_code -ne 0 ] || [ -z "$api_result" ]; then
        # logger "luci.bandix.metrics: curl failed or empty response, returning empty metrics"
        # 返回空结果（原始格式）
        echo '{"retention_seconds":600,"mac":"","metrics":[]}'
        return
    fi
    
    # 使用 jsonfilter 提取 data 部分（根据文档，这是处理大JSON的推荐方式）
    local data_part=$(echo "$api_result" | jsonfilter -e '$.data' 2>/dev/null)
    if [ -n "$data_part" ]; then
        local data_size=${#data_part}
        # logger "luci.bandix.metrics: extracted data part using jsonfilter, size: $data_size bytes"
        echo "$data_part"
        return
    else
        # logger "luci.bandix.metrics: jsonfilter failed to extract data part"
        echo '{"retention_seconds":600,"mac":"","metrics":[]}'
    fi
}

# 设置设备主机名绑定
set_device_hostname() {
	local mac="$1"
	local hostname="$2"

	# logger "luci.bandix: set_device_hostname 参数: mac=$mac hostname=$hostname"
	
	# 验证参数
	if [ -z "$mac" ]; then
		make_error "MAC address is required"
		return
	fi
	
	# hostname可以为空，表示删除绑定
	if [ -z "$hostname" ]; then
		hostname=""
	fi
	
	# 转义特殊字符
	local mac_escaped=$(escape_json_string "$mac")
	local hostname_escaped=$(escape_json_string "$hostname")
	
	# 构建请求数据
	local request_data="{
		\"mac\": \"$mac\",
		\"hostname\": \"$hostname\"
	}"
	
	# 记录请求数据（用于调试）
	# logger "luci.bandix: hostname request_data=$request_data"
	
	# 发送请求到bandix API
	local bindings_api="$BANDIX_API_BASE/api/traffic/bindings"
	local response=$(curl -s --connect-timeout 3 --max-time 10 -X POST -H "Content-Type: application/json" -d "$request_data" "$bindings_api" 2>/dev/null)
	
	# logger "luci.bandix: hostname API response=$response"
	
	if [ $? -eq 0 ] && [ -n "$response" ]; then
		# 检查API响应是否包含success状态
		if echo "$response" | grep -q '"status":\s*"success"'; then
			make_success "Hostname binding set successfully"
		else
			# API返回了响应但不是success状态
			json_init
			json_add_boolean "success" 0
			json_add_string "error" "API returned error response"
			json_add_string "response" "$response"
			json_dump
			json_cleanup
		fi
	else
		make_error "Failed to set hostname binding"
	fi
}

# 获取连接监控数据
get_connection_devices() {
	# 检查连接监控是否启用
	local connection_enabled=$(uci get bandix.connections.enabled 2>/dev/null)
	if [ "$connection_enabled" != "1" ]; then
		make_error "Connection monitoring is not enabled"
		return
	fi
	
	# 从 Bandix API 获取连接数据
	local response=$(curl -s --connect-timeout 2 --max-time 5 -X GET "$BANDIX_CONNECTION_API" 2>/dev/null)
	
	# 检查API调用是否成功
	if [ $? -ne 0 ] || [ -z "$response" ]; then
		make_error "Failed to connect to Bandix service"
		return
	fi
	
	# 直接返回API结果
	echo "$response"
}

# 获取 DNS 查询记录
get_dns_queries() {
	# 检查 DNS 监控是否启用
	local dns_enabled=$(uci get bandix.dns.enabled 2>/dev/null)
	if [ "$dns_enabled" != "1" ]; then
		make_error "DNS monitoring is not enabled"
		return
	fi
	
	# 构建查询参数
	local query_params=""
	local domain="$1"
	local device="$2"
	local is_query="$3"
	local dns_server="$4"
	local query_type="$5"
	local page="$6"
	local page_size="$7"
	
	[ -n "$domain" ] && query_params="${query_params}domain=$(printf '%s' "$domain" | sed 's/ /%20/g')&"
	[ -n "$device" ] && query_params="${query_params}device=$(printf '%s' "$device" | sed 's/ /%20/g')&"
	[ -n "$is_query" ] && query_params="${query_params}is_query=$is_query&"
	[ -n "$dns_server" ] && query_params="${query_params}dns_server=$(printf '%s' "$dns_server" | sed 's/ /%20/g')&"
	[ -n "$query_type" ] && query_params="${query_params}query_type=$(printf '%s' "$query_type" | sed 's/ /%20/g')&"
	[ -n "$page" ] && query_params="${query_params}page=$page&"
	[ -n "$page_size" ] && query_params="${query_params}page_size=$page_size&"
	
	# 移除末尾的 &
	query_params=$(echo "$query_params" | sed 's/&$//')
	
	local url="$BANDIX_DNS_QUERIES_API"
	[ -n "$query_params" ] && url="${url}?${query_params}"
	
	# 从 Bandix API 获取 DNS 查询数据
	local response=$(curl -s --connect-timeout 2 --max-time 10 -X GET "$url" 2>/dev/null)
	
	# 检查API调用是否成功
	if [ $? -ne 0 ] || [ -z "$response" ]; then
		make_error "Failed to connect to Bandix service"
		return
	fi
	
	# 直接返回API结果
	echo "$response"
}

# 获取 DNS 统计信息
get_dns_stats() {
	# 检查 DNS 监控是否启用
	local dns_enabled=$(uci get bandix.dns.enabled 2>/dev/null)
	if [ "$dns_enabled" != "1" ]; then
		make_error "DNS monitoring is not enabled"
		return
	fi
	
	# 从 Bandix API 获取 DNS 统计数据
	local response=$(curl -s --connect-timeout 2 --max-time 10 -X GET "$BANDIX_DNS_STATS_API" 2>/dev/null)
	
	# 检查API调用是否成功
	if [ $? -ne 0 ] || [ -z "$response" ]; then
		make_error "Failed to connect to Bandix service"
		return
	fi
	
	# 直接返回API结果
	echo "$response"
}

# 获取定时限速规则
get_schedule_limits() {
	# 从 Bandix API 获取定时限速规则
	local response=$(curl -s --connect-timeout 2 --max-time 5 -X GET "$BANDIX_SCHEDULE_LIMITS_API" 2>/dev/null)
	
	# 检查API调用是否成功
	if [ $? -ne 0 ] || [ -z "$response" ]; then
		make_error "Failed to connect to Bandix service"
		return
	fi
	
	# 直接返回API结果
	echo "$response"
}

# 设置定时限速规则
set_schedule_limit() {
	local mac="$1"
	local start_time="$2"
	local end_time="$3"
	local days="$4"
	local wide_tx_rate_limit="$5"
	local wide_rx_rate_limit="$6"
	
	# 验证参数
	if [ -z "$mac" ]; then
		make_error "MAC address is required"
		return
	fi
	
	if [ -z "$start_time" ] || [ -z "$end_time" ] || [ -z "$days" ]; then
		make_error "Time slot parameters are required"
		return
	fi
	
	# 转义MAC地址中的特殊字符
	local mac_escaped=$(escape_json_string "$mac")
	
	# 构建请求数据
	local request_data="{
		\"mac\": \"$mac\",
		\"time_slot\": {
			\"start\": \"$start_time\",
			\"end\": \"$end_time\",
			\"days\": $days
		},
		\"wide_tx_rate_limit\": $wide_tx_rate_limit,
		\"wide_rx_rate_limit\": $wide_rx_rate_limit
	}"
	
	# 发送请求到bandix API
	local response=$(curl -s --connect-timeout 3 --max-time 10 -X POST -H "Content-Type: application/json" -d "$request_data" "$BANDIX_SCHEDULE_LIMITS_API" 2>/dev/null)
	
	if [ $? -eq 0 ] && [ -n "$response" ]; then
		# 检查API响应是否包含success状态
		if echo "$response" | grep -q '"status":\s*"success"'; then
			make_success "Schedule limit set successfully"
		else
			# API返回了响应但不是success状态
			json_init
			json_add_boolean "success" 0
			json_add_string "error" "API returned error response"
			json_add_string "response" "$response"
			json_dump
			json_cleanup
		fi
	else
		make_error "Failed to set schedule limit"
	fi
}

# 删除定时限速规则
delete_schedule_limit() {
	local mac="$1"
	local start_time="$2"
	local end_time="$3"
	local days="$4"
	
	# 验证参数
	if [ -z "$mac" ]; then
		make_error "MAC address is required"
		return
	fi
	
	if [ -z "$start_time" ] || [ -z "$end_time" ] || [ -z "$days" ]; then
		make_error "Time slot parameters are required"
		return
	fi
	
	# 转义MAC地址中的特殊字符
	local mac_escaped=$(escape_json_string "$mac")
	
	# 构建请求数据
	local request_data="{
		\"mac\": \"$mac\",
		\"time_slot\": {
			\"start\": \"$start_time\",
			\"end\": \"$end_time\",
			\"days\": $days
		}
	}"
	
	# 发送请求到bandix API
	local response=$(curl -s --connect-timeout 3 --max-time 10 -X DELETE -H "Content-Type: application/json" -d "$request_data" "$BANDIX_SCHEDULE_LIMITS_API" 2>/dev/null)
	
	if [ $? -eq 0 ] && [ -n "$response" ]; then
		# 检查API响应是否包含success状态
		if echo "$response" | grep -q '"status":\s*"success"'; then
			make_success "Schedule limit deleted successfully"
		else
			# API返回了响应但不是success状态
			json_init
			json_add_boolean "success" 0
			json_add_string "error" "API returned error response"
			json_add_string "response" "$response"
			json_dump
			json_cleanup
		fi
	else
		make_error "Failed to delete schedule limit"
	fi
}

case "$1" in
	list)
		json_init
		json_add_object "getStatus"
		json_close_object
		
		json_add_object "getMetrics"
		json_add_string "mac"
		json_close_object
		
		json_add_object "setHostname"
		json_add_string "mac"
		json_add_string "hostname"
		json_close_object
		
		json_add_object "getConnection"
		json_close_object
		
		json_add_object "getDnsQueries"
		json_add_string "domain"
		json_add_string "device"
		json_add_string "is_query"
		json_add_string "dns_server"
		json_add_string "query_type"
		json_add_int "page"
		json_add_int "page_size"
		json_close_object
		
		json_add_object "getDnsStats"
		json_close_object
		
		json_add_object "getScheduleLimits"
		json_close_object
		
		json_add_object "setScheduleLimit"
		json_add_string "mac"
		json_add_string "start_time"
		json_add_string "end_time"
		json_add_string "days"
		json_add_int "wide_rx_rate_limit"
		json_add_int "wide_tx_rate_limit"
		json_close_object
		
		json_add_object "deleteScheduleLimit"
		json_add_string "mac"
		json_add_string "start_time"
		json_add_string "end_time"
		json_add_string "days"
		json_close_object
		
		json_dump
		json_cleanup
		;;
	call)
		case "$2" in
			getStatus)
				get_device_status
				;;
			getMetrics)
				# logger "luci.bandix: getMetrics called"
				# 读取参数：优先 STDIN（带超时，避免阻塞），其次位置参数（$3）
				# 很奇怪收到的是 received input: {"mac":"70:e2:84:2b:9f:42","ubus_rpc_session":"4b0c5dcd9baf9963e4f13647fa71228a"}
				mac=""
				input=""
				# 尝试读取一行 STDIN，1 秒超时以避免在无输入场景下阻塞
				if read -t 1 -r input; then
					:
				fi
				if [ -n "$input" ]; then
					# logger "luci.bandix: received input: $input"
					# 支持数组或对象两种风格
					mac="$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)"
					[ -z "$mac" ] && mac="$(echo "$input" | jsonfilter -e '$.mac' 2>/dev/null)"
				else
					# 某些环境不会通过 STDIN 传参，改为读取位置参数
					[ -n "$3" ] && mac="$3"
					# logger "luci.bandix: received argv mac: $mac"
				fi
				get_metrics "$mac"
				;;
			setHostname)
				# logger "luci.bandix: setHostname called"
				
				# 从 stdin 读取 JSON 参数
				read input
				# logger "luci.bandix: received input: $input"
				
				if [ -n "$input" ]; then
					# 尝试解析数组格式的 JSON 参数 (LuCI RPC 通常使用数组格式)
					# 参数格式: ["mac", "hostname"]
					mac=$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)
					hostname=$(echo "$input" | jsonfilter -e '$[1]' 2>/dev/null)
					
					# 如果数组格式解析失败，尝试对象格式
					if [ -z "$mac" ]; then
						mac=$(echo "$input" | jsonfilter -e '$.mac' 2>/dev/null)
						hostname=$(echo "$input" | jsonfilter -e '$.hostname' 2>/dev/null)
					fi
					
					# logger "luci.bandix: parsed - mac=$mac hostname=$hostname"
					
					# 验证参数（hostname可以为空）
					if [ -n "$mac" ]; then
						# 调用主机名设置函数
						set_device_hostname "$mac" "$hostname"
					else
						# logger "luci.bandix: setHostname MAC参数缺失"
						make_error "Missing MAC address parameter"
					fi
				else
					# logger "luci.bandix: setHostname 没有接收到输入"
					make_error "No input received"
				fi
				;;
			getConnection)
				# logger "luci.bandix: getConnection called"
				get_connection_devices
				;;
			getDnsQueries)
				# logger "luci.bandix: getDnsQueries called"
				# 从 stdin 读取 JSON 参数
				read input
				
				if [ -n "$input" ]; then
					# 解析参数
					domain=$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)
					[ -z "$domain" ] && domain=$(echo "$input" | jsonfilter -e '$.domain' 2>/dev/null)
					
					device=$(echo "$input" | jsonfilter -e '$[1]' 2>/dev/null)
					[ -z "$device" ] && device=$(echo "$input" | jsonfilter -e '$.device' 2>/dev/null)
					
					is_query=$(echo "$input" | jsonfilter -e '$[2]' 2>/dev/null)
					[ -z "$is_query" ] && is_query=$(echo "$input" | jsonfilter -e '$.is_query' 2>/dev/null)
					
					dns_server=$(echo "$input" | jsonfilter -e '$[3]' 2>/dev/null)
					[ -z "$dns_server" ] && dns_server=$(echo "$input" | jsonfilter -e '$.dns_server' 2>/dev/null)
					
					query_type=$(echo "$input" | jsonfilter -e '$[4]' 2>/dev/null)
					[ -z "$query_type" ] && query_type=$(echo "$input" | jsonfilter -e '$.query_type' 2>/dev/null)
					
					page=$(echo "$input" | jsonfilter -e '$[5]' 2>/dev/null)
					[ -z "$page" ] && page=$(echo "$input" | jsonfilter -e '$.page' 2>/dev/null)
					
					page_size=$(echo "$input" | jsonfilter -e '$[6]' 2>/dev/null)
					[ -z "$page_size" ] && page_size=$(echo "$input" | jsonfilter -e '$.page_size' 2>/dev/null)
					
					get_dns_queries "$domain" "$device" "$is_query" "$dns_server" "$query_type" "$page" "$page_size"
				else
					get_dns_queries "" "" "" "" "" "" ""
				fi
				;;
			getDnsStats)
				# logger "luci.bandix: getDnsStats called"
				get_dns_stats
				;;
			getScheduleLimits)
				# logger "luci.bandix: getScheduleLimits called"
				get_schedule_limits
				;;
			setScheduleLimit)
				# logger "luci.bandix: setScheduleLimit called"
				
				# 从 stdin 读取 JSON 参数
				read input
				# logger "luci.bandix: received input: $input"
				
				if [ -n "$input" ]; then
					# 尝试解析数组格式的 JSON 参数 (LuCI RPC 通常使用数组格式)
					# 参数格式: ["mac", "start_time", "end_time", "days", wide_tx_rate_limit, wide_rx_rate_limit]
					mac=$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)
					start_time=$(echo "$input" | jsonfilter -e '$[1]' 2>/dev/null)
					end_time=$(echo "$input" | jsonfilter -e '$[2]' 2>/dev/null)
					# days 可能是 JSON 数组字符串，需要特殊处理
					days=$(echo "$input" | jsonfilter -e '$[3]' 2>/dev/null)
					# 如果提取失败，尝试作为字符串提取
					if [ -z "$days" ]; then
						days=$(echo "$input" | jsonfilter -e '$[3]' -s 2>/dev/null)
					fi
					wide_tx_rate_limit=$(echo "$input" | jsonfilter -e '$[4]' 2>/dev/null)
					wide_rx_rate_limit=$(echo "$input" | jsonfilter -e '$[5]' 2>/dev/null)
					
					# 如果数组格式解析失败，尝试对象格式
					if [ -z "$mac" ]; then
						mac=$(echo "$input" | jsonfilter -e '$.mac' 2>/dev/null)
						start_time=$(echo "$input" | jsonfilter -e '$.start_time' 2>/dev/null)
						end_time=$(echo "$input" | jsonfilter -e '$.end_time' 2>/dev/null)
						# days 可能是 JSON 数组字符串
						days=$(echo "$input" | jsonfilter -e '$.days' 2>/dev/null)
						# 如果提取失败，尝试提取为 JSON 数组
						if [ -z "$days" ]; then
							days=$(echo "$input" | jsonfilter -e '$.days' -s 2>/dev/null)
						fi
						wide_tx_rate_limit=$(echo "$input" | jsonfilter -e '$.wide_tx_rate_limit' 2>/dev/null)
						wide_rx_rate_limit=$(echo "$input" | jsonfilter -e '$.wide_rx_rate_limit' 2>/dev/null)
					fi
					
					# 如果 days 还不是有效的 JSON 数组格式，尝试从原始输入中提取
					if [ -z "$days" ] || ! echo "$days" | grep -q '^\['; then
						# 尝试直接提取 days 字段的值
						days=$(echo "$input" | sed -n 's/.*"days"[[:space:]]*:[[:space:]]*\(\[.*\]\).*/\1/p' 2>/dev/null)
					fi
					
					# logger "luci.bandix: parsed - mac=$mac start=$start_time end=$end_time days=$days tx=$wide_tx_rate_limit rx=$wide_rx_rate_limit"
					
					# 验证参数
					if [ -n "$mac" ] && [ -n "$start_time" ] && [ -n "$end_time" ] && [ -n "$days" ] && [ -n "$wide_tx_rate_limit" ] && [ -n "$wide_rx_rate_limit" ]; then
						# 调用定时限速设置函数
						set_schedule_limit "$mac" "$start_time" "$end_time" "$days" "$wide_tx_rate_limit" "$wide_rx_rate_limit"
					else
						# logger "luci.bandix: setScheduleLimit 参数缺失或无效"
						make_error "Missing or invalid parameters"
					fi
				else
					# logger "luci.bandix: setScheduleLimit 没有接收到输入"
					make_error "No input received"
				fi
				;;
			deleteScheduleLimit)
				# logger "luci.bandix: deleteScheduleLimit called"
				
				# 从 stdin 读取 JSON 参数
				read input
				# logger "luci.bandix: received input: $input"
				
				if [ -n "$input" ]; then
					# 尝试解析数组格式的 JSON 参数 (LuCI RPC 通常使用数组格式)
					# 参数格式: ["mac", "start_time", "end_time", "days"]
					mac=$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)
					start_time=$(echo "$input" | jsonfilter -e '$[1]' 2>/dev/null)
					end_time=$(echo "$input" | jsonfilter -e '$[2]' 2>/dev/null)
					# days 可能是 JSON 数组字符串，需要特殊处理
					days=$(echo "$input" | jsonfilter -e '$[3]' 2>/dev/null)
					# 如果提取失败，尝试作为字符串提取
					if [ -z "$days" ]; then
						days=$(echo "$input" | jsonfilter -e '$[3]' -s 2>/dev/null)
					fi
					
					# 如果数组格式解析失败，尝试对象格式
					if [ -z "$mac" ]; then
						mac=$(echo "$input" | jsonfilter -e '$.mac' 2>/dev/null)
						start_time=$(echo "$input" | jsonfilter -e '$.start_time' 2>/dev/null)
						end_time=$(echo "$input" | jsonfilter -e '$.end_time' 2>/dev/null)
						# days 可能是 JSON 数组字符串
						days=$(echo "$input" | jsonfilter -e '$.days' 2>/dev/null)
						# 如果提取失败，尝试提取为 JSON 数组
						if [ -z "$days" ]; then
							days=$(echo "$input" | jsonfilter -e '$.days' -s 2>/dev/null)
						fi
					fi
					
					# 如果 days 还不是有效的 JSON 数组格式，尝试从原始输入中提取
					if [ -z "$days" ] || ! echo "$days" | grep -q '^\['; then
						# 尝试直接提取 days 字段的值
						days=$(echo "$input" | sed -n 's/.*"days"[[:space:]]*:[[:space:]]*\(\[.*\]\).*/\1/p' 2>/dev/null)
					fi
					
					# logger "luci.bandix: parsed - mac=$mac start=$start_time end=$end_time days=$days"
					
					# 验证参数
					if [ -n "$mac" ] && [ -n "$start_time" ] && [ -n "$end_time" ] && [ -n "$days" ]; then
						# 调用定时限速删除函数
						delete_schedule_limit "$mac" "$start_time" "$end_time" "$days"
					else
						# logger "luci.bandix: deleteScheduleLimit 参数缺失或无效"
						make_error "Missing or invalid parameters"
					fi
				else
					# logger "luci.bandix: deleteScheduleLimit 没有接收到输入"
					make_error "No input received"
				fi
				;;
		esac
		;;
esac
