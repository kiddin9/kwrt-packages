#!/bin/sh
# Copyright 2024 timsaya

. /usr/share/libubox/jshn.sh

# 从UCI配置读取端口号，如果读取失败则使用默认端口8686
BANDIX_PORT=$(uci get bandix.general.port 2>/dev/null || echo "8686")
readonly BANDIX_API_BASE="http://127.0.0.1:$BANDIX_PORT"
readonly BANDIX_DEVICES_API="$BANDIX_API_BASE/api/traffic/devices"
readonly BANDIX_LIMITS_API="$BANDIX_API_BASE/api/traffic/limits"
readonly BANDIX_METRICS_API="$BANDIX_API_BASE/api/traffic/metrics"
readonly BANDIX_CONNECTION_API="$BANDIX_API_BASE/api/connection/devices"
readonly DHCP_LEASES_FILE="/tmp/dhcp.leases"

# 通用函数：创建简单的JSON响应
make_value() {
	json_init
	json_add_string "$1" "$2"
	json_dump
	json_cleanup
}

# 通用函数：创建错误响应
make_error() {
	json_init
	json_add_boolean "success" 0
	json_add_string "error" "$1"
	json_dump
	json_cleanup
}

# 通用函数：创建成功响应
make_success() {
	json_init
	json_add_boolean "success" 1
	[ -n "$1" ] && json_add_string "message" "$1"
	json_dump
	json_cleanup
}

# 转义JSON字符串
escape_json_string() {
	echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g'
}

# 获取设备状态
get_device_status() {
	# 预先一次性读取 DHCP 租约文件到内存，避免在循环中重复读取
	local dhcp_leases_content=""
	if [ -f "$DHCP_LEASES_FILE" ]; then
		dhcp_leases_content=$(cat "$DHCP_LEASES_FILE")
	fi

	local api_result=$(curl -s --connect-timeout 2 --max-time 5 "$BANDIX_DEVICES_API" 2>/dev/null)
	
	# 检查API调用是否成功
	if [ $? -ne 0 ] || [ -z "$api_result" ]; then
		json_init
		json_add_object "status"
		json_add_boolean "success" 0
		json_add_string "error" "Failed to connect to bandix service"
		json_close_object
		json_add_array "devices"
		json_close_array
		json_dump
		json_cleanup
		return
	fi
	
	# 从原始API结果加载JSON
	if ! json_load "$api_result"; then
		json_init
		json_add_object "status"
		json_add_boolean "success" 0
		json_add_string "error" "Invalid JSON response from bandix service"
		json_close_object
		json_add_array "devices"
		json_close_array
		json_dump
		json_cleanup
		return
	fi
	
	# 检查API状态
	local api_status
	json_get_var api_status status
	if [ "$api_status" != "success" ]; then
		json_init
		json_add_object "status"
		json_add_boolean "success" 0
		json_add_string "error" "API returned failure status"
		json_close_object
		json_add_array "devices"
		json_close_array
		json_dump
		json_cleanup
		return
	fi

	# 提取data对象
	if ! json_select "data"; then
		json_init
		json_add_object "status"
		json_add_boolean "success" 0
		json_add_string "error" "No data field in API response"
		json_close_object
		json_add_array "devices"
		json_close_array
		json_dump
		json_cleanup
		return
	fi

	# 提取设备数组
	if ! json_select "devices"; then
		json_init
		json_add_object "status"
		json_add_boolean "success" 0
		json_add_string "error" "No devices field in data"
		json_close_object
		json_add_array "devices"
		json_close_array
		json_dump
		json_cleanup
		return
	fi
	
	json_get_keys device_indexes
	
	# 开始构建新的JSON
	echo '{'
	echo '  "devices": ['
	
	# 标记是否是第一个设备
	local first_device=1
	
	# 检查是否有设备数据
	if [ -z "$device_indexes" ]; then
		# 没有设备数据，返回空数组
		echo
		echo '  ]'
		echo '}'
		return
	fi
	
	# 遍历每个设备
	for idx in $device_indexes; do
		json_select "$idx"
		
		# 获取设备信息
		json_get_var mac mac
		json_get_var ip ip
		json_get_var hostname hostname
		json_get_var total_rx_bytes total_rx_bytes
		json_get_var total_tx_bytes total_tx_bytes
		json_get_var total_rx_rate total_rx_rate
		json_get_var total_tx_rate total_tx_rate
		json_get_var local_rx_bytes local_rx_bytes
		json_get_var local_tx_bytes local_tx_bytes
		json_get_var local_rx_rate local_rx_rate
		json_get_var local_tx_rate local_tx_rate
		json_get_var wide_rx_bytes wide_rx_bytes
		json_get_var wide_tx_bytes wide_tx_bytes
		json_get_var wide_rx_rate wide_rx_rate
		json_get_var wide_tx_rate wide_tx_rate
		json_get_var wide_rx_rate_limit wide_rx_rate_limit
		json_get_var wide_tx_rate_limit wide_tx_rate_limit
		json_get_var last_online_ts last_online_ts
		
		# 只有当接口中的hostname为空时，才从缓存的DHCP数据中查找对应的主机名
		if [ -z "$hostname" ] && [ -n "$dhcp_leases_content" ]; then
			local mac_lower=$(echo "$mac" | tr 'A-Z' 'a-z')
			# 从缓存中查找匹配的MAC地址，提取hostname字段
			local dhcp_hostname=$(echo "$dhcp_leases_content" | grep -i "$mac" | awk '{if ($4 != "*") print $4}' | head -1)
			if [ -n "$dhcp_hostname" ]; then
				hostname="$dhcp_hostname"
			fi
		fi
		
		# 添加逗号分隔符（除了第一个设备）
		if [ "$first_device" -eq 1 ]; then
			first_device=0
		else
			echo ','
		fi
		
		# 转义hostname中的特殊字符
		local hostname_escaped=$(escape_json_string "$hostname")
		
		# 输出设备信息到JSON
		cat <<EOF
		{
			"mac": "$mac",
			"ip": "$ip",
			"hostname": "$hostname_escaped",
			"total_rx_bytes": ${total_rx_bytes:-0},
			"total_tx_bytes": ${total_tx_bytes:-0},
			"total_rx_rate": ${total_rx_rate:-0},
			"total_tx_rate": ${total_tx_rate:-0},
			"local_rx_bytes": ${local_rx_bytes:-0},
			"local_tx_bytes": ${local_tx_bytes:-0},
			"local_rx_rate": ${local_rx_rate:-0},
			"local_tx_rate": ${local_tx_rate:-0},
			"wide_rx_bytes": ${wide_rx_bytes:-0},
			"wide_tx_bytes": ${wide_tx_bytes:-0},
			"wide_rx_rate": ${wide_rx_rate:-0},
			"wide_tx_rate": ${wide_tx_rate:-0},
			"wide_rx_rate_limit": ${wide_rx_rate_limit:-0},
			"wide_tx_rate_limit": ${wide_tx_rate_limit:-0},
			"last_online_ts": ${last_online_ts:-0}
		}
EOF
		
		# 返回到设备数组
		json_select ..
	done
	
	# 完成JSON结构
	echo
	echo '  ]'
	echo '}'
}

# 获取历史指标（可选MAC）
get_metrics() {
    local mac="$1"
    local url="$BANDIX_METRICS_API"
    if [ -n "$mac" ]; then
        # 转义MAC
        local mac_escaped=$(echo "$mac" | sed 's/\//\\\//g')
        url="$url?mac=$mac_escaped"
    fi

    # logger "luci.bandix.metrics: entering mac=$mac url=$url"
    local api_result=$(curl -s --connect-timeout 1 --max-time 3 "$url" 2>/dev/null)
    local curl_exit_code=$?
    # logger "luci.bandix.metrics: curl finished with exit code: $curl_exit_code"
    
    if [ $curl_exit_code -ne 0 ] || [ -z "$api_result" ]; then
        # logger "luci.bandix.metrics: curl failed or empty response, returning empty metrics"
        # 返回空结果（原始格式）
        echo '{"retention_seconds":600,"mac":"","metrics":[]}'
        return
    fi

    local response_size=${#api_result}
    # logger "luci.bandix.metrics: response size: $response_size bytes, processing new API format"
    
    # 检查响应格式并使用 jsonfilter 提取状态
    local api_status=$(echo "$api_result" | jsonfilter -e '$.status' 2>/dev/null)
    if [ "$api_status" != "success" ]; then
        # logger "luci.bandix.metrics: API status is not success: '$api_status'"
        echo '{"retention_seconds":600,"mac":"","metrics":[]}'
        return
    fi
    # logger "luci.bandix.metrics: confirmed API success status"
    
    # 使用 jsonfilter 提取 data 部分（根据文档，这是处理大JSON的推荐方式）
    local data_part=$(echo "$api_result" | jsonfilter -e '$.data' 2>/dev/null)
    if [ -n "$data_part" ]; then
        local data_size=${#data_part}
        # logger "luci.bandix.metrics: extracted data part using jsonfilter, size: $data_size bytes"
        echo "$data_part"
        return
    else
        # logger "luci.bandix.metrics: jsonfilter failed to extract data part"
        echo '{"retention_seconds":600,"mac":"","metrics":[]}'
    fi
}

# 设置设备限速
set_device_rate_limit() {
	local mac="$1"
	local wide_tx_rate_limit="$2"
	local wide_rx_rate_limit="$3"

	# logger "luci.bandix: set_device_rate_limit 参数: mac=$mac tx=$wide_tx_rate_limit rx=$wide_rx_rate_limit"
	
	# 验证参数
	if [ -z "$mac" ]; then
		make_error "MAC address is required"
		return
	fi
	
	# 转义MAC地址中的特殊字符
	local mac_escaped=$(escape_json_string "$mac")
	
	# 构建请求数据
	local request_data="{
		\"mac\": \"$mac\",
		\"wide_tx_rate_limit\": $wide_tx_rate_limit,
		\"wide_rx_rate_limit\": $wide_rx_rate_limit
	}"
	
	# 记录请求数据（用于调试）
	# logger "luci.bandix: request_data=$request_data"
	
	# 发送请求到bandix API
	local response=$(curl -s --connect-timeout 3 --max-time 10 -X POST -H "Content-Type: application/json" -d "$request_data" "$BANDIX_LIMITS_API" 2>/dev/null)
	
	# logger "luci.bandix: API response=$response"
	
	if [ $? -eq 0 ] && [ -n "$response" ]; then
		# 检查API响应是否包含success状态
		if echo "$response" | grep -q '"status":\s*"success"'; then
			make_success "Rate limit set successfully"
		else
			# API返回了响应但不是success状态
			json_init
			json_add_boolean "success" 0
			json_add_string "error" "API returned error response"
			json_add_string "response" "$response"
			json_dump
			json_cleanup
		fi
	else
		make_error "Failed to set rate limit"
	fi
}

# 设置设备主机名绑定
set_device_hostname() {
	local mac="$1"
	local hostname="$2"

	# logger "luci.bandix: set_device_hostname 参数: mac=$mac hostname=$hostname"
	
	# 验证参数
	if [ -z "$mac" ]; then
		make_error "MAC address is required"
		return
	fi
	
	# hostname可以为空，表示删除绑定
	if [ -z "$hostname" ]; then
		hostname=""
	fi
	
	# 转义特殊字符
	local mac_escaped=$(escape_json_string "$mac")
	local hostname_escaped=$(escape_json_string "$hostname")
	
	# 构建请求数据
	local request_data="{
		\"mac\": \"$mac\",
		\"hostname\": \"$hostname\"
	}"
	
	# 记录请求数据（用于调试）
	# logger "luci.bandix: hostname request_data=$request_data"
	
	# 发送请求到bandix API
	local bindings_api="$BANDIX_API_BASE/api/traffic/bindings"
	local response=$(curl -s --connect-timeout 3 --max-time 10 -X POST -H "Content-Type: application/json" -d "$request_data" "$bindings_api" 2>/dev/null)
	
	# logger "luci.bandix: hostname API response=$response"
	
	if [ $? -eq 0 ] && [ -n "$response" ]; then
		# 检查API响应是否包含success状态
		if echo "$response" | grep -q '"status":\s*"success"'; then
			make_success "Hostname binding set successfully"
		else
			# API返回了响应但不是success状态
			json_init
			json_add_boolean "success" 0
			json_add_string "error" "API returned error response"
			json_add_string "response" "$response"
			json_dump
			json_cleanup
		fi
	else
		make_error "Failed to set hostname binding"
	fi
}

# 获取连接监控数据
get_connection_devices() {
	# 检查连接监控是否启用
	local connection_enabled=$(uci get bandix.connections.enabled 2>/dev/null)
	if [ "$connection_enabled" != "1" ]; then
		make_error "Connection monitoring is not enabled"
		return
	fi
	
	# 预先一次性读取 DHCP 租约文件到内存，避免在循环中重复读取
	local dhcp_leases_content=""
	if [ -f "$DHCP_LEASES_FILE" ]; then
		dhcp_leases_content=$(cat "$DHCP_LEASES_FILE")
	fi
	
	# 从 Bandix API 获取连接数据
	local response=$(curl -s --connect-timeout 2 --max-time 5 -X GET "$BANDIX_CONNECTION_API" 2>/dev/null)
	
	if [ $? -eq 0 ] && [ -n "$response" ]; then
		# 检查响应状态
		local status=$(echo "$response" | jsonfilter -e '$.status' 2>/dev/null)
		if [ "$status" = "success" ]; then
			# 获取设备数据并添加主机名信息
			local devices_data=$(echo "$response" | jsonfilter -e '$.data.devices')
			local global_stats=$(echo "$response" | jsonfilter -e '$.data.global_stats')
			local total_devices=$(echo "$response" | jsonfilter -e '$.data.total_devices')
			local last_updated=$(echo "$response" | jsonfilter -e '$.data.last_updated')
			
			# 构建增强的响应数据
			json_init
			json_add_string "status" "success"
			json_add_object "data"
			
			# 添加全局统计
			if [ -n "$global_stats" ]; then
				json_add_object "global_stats"
				json_add_int "total_connections" $(echo "$response" | jsonfilter -e '$.data.global_stats.total_connections' 2>/dev/null || echo "0")
				json_add_int "tcp_connections" $(echo "$response" | jsonfilter -e '$.data.global_stats.tcp_connections' 2>/dev/null || echo "0")
				json_add_int "udp_connections" $(echo "$response" | jsonfilter -e '$.data.global_stats.udp_connections' 2>/dev/null || echo "0")
				json_add_int "established_tcp" $(echo "$response" | jsonfilter -e '$.data.global_stats.established_tcp' 2>/dev/null || echo "0")
				json_add_int "time_wait_tcp" $(echo "$response" | jsonfilter -e '$.data.global_stats.time_wait_tcp' 2>/dev/null || echo "0")
				json_add_int "close_wait_tcp" $(echo "$response" | jsonfilter -e '$.data.global_stats.close_wait_tcp' 2>/dev/null || echo "0")
				json_add_int "last_updated" $(echo "$response" | jsonfilter -e '$.data.global_stats.last_updated' 2>/dev/null || echo "0")
				json_close_object
			fi
			
			# 添加设备数据
			json_add_array "devices"
			if [ -n "$devices_data" ]; then
				# 解析设备数组 - 一次性提取所有设备的 JSON 字符串，避免重复解析
				local device_count=$(echo "$response" | jsonfilter -e '$.data.devices[*]' | wc -l)
				local i=0
				while [ $i -lt $device_count ]; do
					# 一次性提取当前设备的所有数据，减少 jsonfilter 调用次数
					local device_json=$(echo "$response" | jsonfilter -e "$.data.devices[$i]" 2>/dev/null)
					
					# 从提取的设备 JSON 中解析各个字段
					local mac=$(echo "$device_json" | jsonfilter -e '$.mac_address' 2>/dev/null)
					local ip=$(echo "$device_json" | jsonfilter -e '$.ip_address' 2>/dev/null)
					local hostname=$(echo "$device_json" | jsonfilter -e '$.hostname' 2>/dev/null)
					local tcp_connections=$(echo "$device_json" | jsonfilter -e '$.tcp_connections' 2>/dev/null || echo "0")
					local udp_connections=$(echo "$device_json" | jsonfilter -e '$.udp_connections' 2>/dev/null || echo "0")
					local established_tcp=$(echo "$device_json" | jsonfilter -e '$.established_tcp' 2>/dev/null || echo "0")
					local time_wait_tcp=$(echo "$device_json" | jsonfilter -e '$.time_wait_tcp' 2>/dev/null || echo "0")
					local close_wait_tcp=$(echo "$device_json" | jsonfilter -e '$.close_wait_tcp' 2>/dev/null || echo "0")
					local total_connections=$(echo "$device_json" | jsonfilter -e '$.total_connections' 2>/dev/null || echo "0")
					local device_last_updated=$(echo "$device_json" | jsonfilter -e '$.last_updated' 2>/dev/null || echo "0")
					
					# 只有当接口中的hostname为空时，才从缓存的DHCP数据中查找对应的主机名
					if [ -z "$hostname" ] && [ -n "$dhcp_leases_content" ] && [ -n "$mac" ]; then
						local dhcp_hostname=$(echo "$dhcp_leases_content" | grep -i "$mac" | awk '{if ($4 != "*") print $4}' | head -1)
						if [ -n "$dhcp_hostname" ]; then
							hostname="$dhcp_hostname"
						fi
					fi
					
					if [ -n "$mac" ] || [ -n "$ip" ]; then
						json_add_object
						json_add_string "mac_address" "$mac"
						json_add_string "ip_address" "$ip"
						json_add_string "hostname" "$hostname"
						json_add_int "tcp_connections" "$tcp_connections"
						json_add_int "udp_connections" "$udp_connections"
						json_add_int "established_tcp" "$established_tcp"
						json_add_int "time_wait_tcp" "$time_wait_tcp"
						json_add_int "close_wait_tcp" "$close_wait_tcp"
						json_add_int "total_connections" "$total_connections"
						json_add_int "last_updated" "$device_last_updated"
						json_close_object
					fi
					
					i=$((i + 1))
				done
			fi
			json_close_array
			
			json_add_int "total_devices" "${total_devices:-0}"
			json_add_int "last_updated" "${last_updated:-0}"
			json_close_object
			json_add_string "message" ""
			json_dump
			json_cleanup
		else
			local error_msg=$(echo "$response" | jsonfilter -e '$.message' 2>/dev/null)
			make_error "${error_msg:-Failed to get connection data}"
		fi
	else
		make_error "Failed to connect to Bandix service"
	fi
}

case "$1" in
	list)
		json_init
		json_add_object "getStatus"
		json_close_object
		
		json_add_object "getMetrics"
		json_add_string "mac"
		json_close_object
		
		json_add_object "setRateLimit"
		json_add_string "mac"
		json_add_int "wide_rx_rate_limit"
		json_add_int "wide_tx_rate_limit"
		json_close_object
		
		json_add_object "setHostname"
		json_add_string "mac"
		json_add_string "hostname"
		json_close_object
		
		json_add_object "getConnection"
		json_close_object
		
		json_dump
		json_cleanup
		;;
	call)
		case "$2" in
			getStatus)
				get_device_status
				;;
			getMetrics)
				# logger "luci.bandix: getMetrics called"
				# 读取参数：优先 STDIN（带超时，避免阻塞），其次位置参数（$3）
				# 很奇怪收到的是 received input: {"mac":"70:e2:84:2b:9f:42","ubus_rpc_session":"4b0c5dcd9baf9963e4f13647fa71228a"}
				mac=""
				input=""
				# 尝试读取一行 STDIN，1 秒超时以避免在无输入场景下阻塞
				if read -t 1 -r input; then
					:
				fi
				if [ -n "$input" ]; then
					# logger "luci.bandix: received input: $input"
					# 支持数组或对象两种风格
					mac="$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)"
					[ -z "$mac" ] && mac="$(echo "$input" | jsonfilter -e '$.mac' 2>/dev/null)"
				else
					# 某些环境不会通过 STDIN 传参，改为读取位置参数
					[ -n "$3" ] && mac="$3"
					# logger "luci.bandix: received argv mac: $mac"
				fi
				get_metrics "$mac"
				;;
			setRateLimit)
				# logger "luci.bandix: setRateLimit called"
				
				# 从 stdin 读取 JSON 参数
				read input
				# logger "luci.bandix: received input: $input"
				
				if [ -n "$input" ]; then
					# 尝试解析数组格式的 JSON 参数 (LuCI RPC 通常使用数组格式)
					# 参数格式: ["mac", wide_tx_rate_limit, wide_rx_rate_limit]
					mac=$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)
					wide_tx_rate_limit=$(echo "$input" | jsonfilter -e '$[1]' 2>/dev/null)
					wide_rx_rate_limit=$(echo "$input" | jsonfilter -e '$[2]' 2>/dev/null)
					
					# 如果数组格式解析失败，尝试对象格式
					if [ -z "$mac" ]; then
						mac=$(echo "$input" | jsonfilter -e '$.mac' 2>/dev/null)
						wide_tx_rate_limit=$(echo "$input" | jsonfilter -e '$.wide_tx_rate_limit' 2>/dev/null)
						wide_rx_rate_limit=$(echo "$input" | jsonfilter -e '$.wide_rx_rate_limit' 2>/dev/null)
					fi
					
					# logger "luci.bandix: parsed - mac=$mac tx=$wide_tx_rate_limit rx=$wide_rx_rate_limit"
					
					# 验证参数
					if [ -n "$mac" ] && [ -n "$wide_tx_rate_limit" ] && [ -n "$wide_rx_rate_limit" ]; then
						# 调用限速设置函数
						set_device_rate_limit "$mac" "$wide_tx_rate_limit" "$wide_rx_rate_limit"
					else
						# logger "luci.bandix: setRateLimit 参数缺失或无效"
						make_error "Missing or invalid parameters"
					fi
				else
					# logger "luci.bandix: setRateLimit 没有接收到输入"
					make_error "No input received"
				fi
				;;
			setHostname)
				# logger "luci.bandix: setHostname called"
				
				# 从 stdin 读取 JSON 参数
				read input
				# logger "luci.bandix: received input: $input"
				
				if [ -n "$input" ]; then
					# 尝试解析数组格式的 JSON 参数 (LuCI RPC 通常使用数组格式)
					# 参数格式: ["mac", "hostname"]
					mac=$(echo "$input" | jsonfilter -e '$[0]' 2>/dev/null)
					hostname=$(echo "$input" | jsonfilter -e '$[1]' 2>/dev/null)
					
					# 如果数组格式解析失败，尝试对象格式
					if [ -z "$mac" ]; then
						mac=$(echo "$input" | jsonfilter -e '$.mac' 2>/dev/null)
						hostname=$(echo "$input" | jsonfilter -e '$.hostname' 2>/dev/null)
					fi
					
					# logger "luci.bandix: parsed - mac=$mac hostname=$hostname"
					
					# 验证参数（hostname可以为空）
					if [ -n "$mac" ]; then
						# 调用主机名设置函数
						set_device_hostname "$mac" "$hostname"
					else
						# logger "luci.bandix: setHostname MAC参数缺失"
						make_error "Missing MAC address parameter"
					fi
				else
					# logger "luci.bandix: setHostname 没有接收到输入"
					make_error "No input received"
				fi
				;;
			getConnection)
				# logger "luci.bandix: getConnection called"
				get_connection_devices
				;;
		esac
		;;
esac
